import java_cup.runtime.*;
action code {::}

parser code{:
public void syntax_error(Symbol s){

		report_error("Error de sintaxis en la linea " + s.left + " caracter " + s.right + "\n", 		null);

	}

	
	public void syntax_error(){

		report_error("Error no puede haber dos funciones principales en el programa ", null);

	}

	
	public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{

		report_error("" , null);

}
:}

terminal define, aperturaParentesis, cierreParentesis, aperturaLlaves, vvoid, cierreLlaves, coma, vint, vfloat, punto_coma, mas, menos, mult, diventera, divreal, numeric_integer_const, numeric_real_const, constlit, igual, vreturn, ident, negacion, or_logic, and_logic, comp_igual, menor_que, mayor_que, mayor_igual_que, menor_igual_que, vif, velse, vwhile, vdo, vuntil, vfor;

non terminal  PROGRAM, DEFINES, PARTES, CTES, PART, RESTPART, BLQ, LISTPARAM, TYPE, SENTLIST, SENT, LID, EXP, LEXP, OP, FACTOR, LCOND, OPL, COND, OPR;

precedence left mult, diventera, divreal;
precedence left mas, menos;
precedence left or_logic, and_logic;

PROGRAM ::= DEFINES:d PARTES:p {:RESULT='program '+'main'+';'+'\n'+d+'\n'+p;:};
DEFINES ::=define ident:i CTES:c DEFINES:d {:RESULT=:'const'+'\n'+'\t'+i+'='+c+d;} |;
CTES ::= numeric_integer_const:n1 {:RESULT=n1;:} | numeric_real_const:n2 {:RESULT=n2;:} | constlit:n3 {:RESULT=n3;:};
PARTES ::= PART:p PARTES:ps {:RESULT=p+ps;:} | PART:p {:RESULT=:p;};
PART ::= TYPE RESTPART {:RESULT=:};
RESTPART ::= ident aperturaParentesis LISTPARAM cierreParentesis BLQ {:RESULT=:} 
		| ident aperturaParentesis vvoid cierreParentesis BLQ {:RESULT=:};
BLQ ::= aperturaLlaves SENTLIST:s cierreLlaves {:RESULT=':};
LISTPARAM ::= LISTPARAM coma TYPE ident {:RESULT=:} | TYPE ident {:RESULT=:};
TYPE ::= vvoid {:RESULT='';:} | vint {:RESULT='INTEGER';:} | vfloat{:RESULT='REAL'::};

SENTLIST ::= SENTLIST SENT {:RESULT=:} | SENT {:RESULT=:};
SENT ::= TYPE LID punto_coma {:RESULT=:} 
		| ident igual EXP punto_coma {:RESULT=:}
		| ident aperturaParentesis LEXP cierreParentesis punto_coma {:RESULT=:}
		| ident aperturaParentesis cierreParentesis punto_coma {:RESULT=:}
		| vreturn EXP punto_coma {:RESULT=:}
		| vif aperturaParentesis LCOND cierreParentesis BLQ velse BLQ {:RESULT=:}
		| vwhile aperturaParentesis LCOND cierreParentesis BLQ {:RESULT=:}
		| vdo BLQ vuntil aperturaParentesis LCOND cierreParentesis {:RESULT=:}
		| vfor aperturaParentesis ident igual EXP punto_coma LCOND punto_coma ident igual EXP cierreParentesis BLQ {:RESULT=:};
LID ::= ident:i {:RESULT=i;:} | LID coma ident {:RESULT=:};
LEXP ::= EXP:exp {:RESULT=epx;:} | LEXP:lexp coma:coma EXP:exp {:RESULT=lexp+coma+exp;:};
EXP ::= EXP:exp1 OP:op EXP:exp2 {:RESULT=exp1+op+exp2;:} | FACTOR:f {:RESULT=f;:};
OP ::= mas:m {:RESULT=m;:} | menos:me {:RESULT=me;:} | mult:mu {:RESULT=mu;:} | diventera {:RESULT='mod';:} | divreal{:RESULT='div';:};
FACTOR ::= ident:i aperturaParentesis LEXP:lexp cierreParentesis {:RESULT=i+'('+lexp+')';:}
		| ident:i aperturaParentesis cierreParentesis {:RESULT=i+'('+')';:}
		| aperturaParentesis EXP:exp cierreParentesis {:RESULT='('+exp+')';:}
		| ident:i {:RESULT=i;:}
		| CTES:c {:RESULT=c;:};

LCOND ::= LCOND:lcond1 OPL:op LCOND:lcond2 {:RESULT=lcond1+op+lcond2;c;:} | COND:c {:RESULT=:} | negacion COND:c {:RESULT='not'+c;:};
OPL ::= or_logic {:RESULT='or';:} | and_logic {:RESULT='and';:};
COND ::= EXP:exp1 OPR:op EXP:exp2 {:RESULT=exp1+op+exp2;:};
OPR::= comp_igual {:RESULT='=';:} | menor_que:meq {:RESULT=meq;:} | mayor_que:mq {:RESULT=mq;:} | mayor_igual_que:miq {:RESULT=miq;:} | menor_igual_que:meiq {:RESULT=meiq;:};